'''
sbc-ngs (c) University of Manchester 2019

All rights reserved.

@author: neilswainston
'''

from __future__ import division

import os
import subprocess
import sys
from typing import Any
import shutil
import re
import time
import traceback

import multiprocessing as mp
import pandas as pd
from sbc_ngs import cps_demultiplex as demultiplex, results, utils, vcf_utils, medaka_utils
from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord

def parse_barcode_excel(input_xlsx, output=None, with_backbone=False):
    barcodes_df = pd.read_excel(input_xlsx,
                                sheet_name='barcode')
    references_df = pd.read_excel(input_xlsx,
                                sheet_name='reference')
        
    if with_backbone:
        barcodes_df = \
            barcodes_df.assign(forward=lambda x:x['forward_barcode'] + x['forward_primer_backbone'],
                               reverse=lambda x:x['reverse_barcode'] + x['reverse_primer_backbone'])
    else:
        barcodes_df = \
            barcodes_df.assign(forward=lambda x:x['forward_barcode'],
                               reverse=lambda x:x['reverse_barcode'])
    if output:
        for i, row in references_df.iterrows():
            SeqIO.write(SeqRecord(Seq(row['sequence']),
                                id=row['known_seq_id'],
                                name=row['known_seq_id'],
                                description=''),
                        os.path.join(output, row['known_seq_id'] + '.fasta'),
                        'fasta')
        if not os.path.isdir(output):
            os.mkdir(output)
        
    return barcodes_df.loc[:,['well',
                       'known_seq_id',
                       'forward',
                       'reverse']]

def _score_alignment_sub(dir_name, barcodes, reads_filename, seq_files,
                     num_threads, write_queue, risk_threshold, risk_threshold2, parallel, mode):
    # >> All code in try / original >>
    # >> if this process is under a multiprocessing
    if parallel == True or str(parallel).lower() == 'parallel':
        sys.stdin = os.fdopen(os.dup(sys.stdin.fileno()))
        print()
        pass
    for seq_id, seq_filename in seq_files.items():
        barcode_dir_name = utils.get_dir(dir_name, barcodes, seq_id)
        bam_filename = os.path.join(barcode_dir_name, '%s.bam' % barcodes[2])
        vcf_filename = bam_filename.replace('.bam', '.vcf')

        #>> replace bwa by minimap2
        # >> intergrated minimap2 and bwa
        if not (os.path.exists(vcf_filename) and os.path.exists(bam_filename)) or os.path.getsize(vcf_filename) == 0:
            if mode == 'bwa':
                prc = subprocess.Popen(('bwa', 'mem',
                                        '-x', 'ont2d',
                                        '-O', '6',
                                        '-t', str(num_threads),
                                        seq_filename, reads_filename),
                                    stdout=subprocess.PIPE)
            elif mode == 'minimap':
                prc = subprocess.Popen(('minimap2',
                                        '-ax', 'map-ont',
                                        '-t', str(num_threads),
                                        seq_filename+'.mmi', reads_filename),
                                    stdout=subprocess.PIPE)
            # << intergrated minimap2 and bwa

            subprocess.check_output(('samtools', 'sort',
                                    '-@%i' % num_threads,
                                    '-o', bam_filename, '-'),
                                    stdin=prc.stdout)
            prc.wait()

            prc = subprocess.Popen(['bcftools',
                                    'mpileup',
                                    '-O', 'v',
                                    '-f', seq_filename,
                                    '-a', 'FORMAT/DP',
                                    '--threads', str(num_threads),
                                    '-o', vcf_filename,
                                    bam_filename])        

            prc.wait()
        # Get Mapped rates
        prc = subprocess.Popen(['samtools',
                                'flagstat',
                                bam_filename],
                                stdout=subprocess.PIPE)
        
        out, err = prc.communicate()
        out = out.decode()

        mapped_reads, mapped_rate = re.search(r'(\d+)\s+\+\s+\d+\s+mapped\s\((\d+\.\d+)%', out).groups()

        mapped_reads = int(mapped_reads)
        mapped_rate = float(mapped_rate)

        write_queue.put(['mapped_reads', mapped_reads, seq_id, barcodes])
        write_queue.put(['mapped_rate', mapped_rate, seq_id, barcodes])

        vcf_utils.analyse(vcf_filename, seq_id, barcodes, write_queue,
                          risk_threshold=risk_threshold,
                          risk_threshold2=risk_threshold2)

        print('Scored: %s against %s' % (reads_filename, seq_id))


def _score_alignment(dir_name, barcodes, reads_filename, seq_files,
                     num_threads, write_queue, risk_threshold, risk_threshold2, parallel, mode, test=False):
    '''Score an alignment.'''
    if test:
        try:
            _score_alignment_sub(dir_name, barcodes, reads_filename, seq_files,
                                num_threads, write_queue, risk_threshold, risk_threshold2, parallel, mode)
        except Exception as e:
            return traceback.format_exc()
    else:
        _score_alignment_sub(dir_name, barcodes, reads_filename, seq_files,
                        num_threads, write_queue, risk_threshold, risk_threshold2, parallel, mode)      
        

class PathwayAligner():
    '''Class to align NGS data to pathways.'''

    def __init__(self, out_dir, in_dir, seq_files=None, min_length=200, max_read_files=5000, barcodes_df=None):
        # Initialise project directory:
        self.__out_dir = out_dir

        if not os.path.exists(self.__out_dir):
            os.makedirs(self.__out_dir)

        self.__in_dir = in_dir
        self.__seq_files = seq_files
        self.__min_length = min_length
        self.__max_read_files = max_read_files
        if barcodes_df is None:
            self.__barcodes, self.__barcodes_df = \
                demultiplex.get_barcodes(os.path.join(in_dir, 'barcodes.csv'))
        else:
            self.__barcodes, self.__barcodes_df = \
                demultiplex.get_barcodes(barcodes_df)

        # Backwards compatibility:
        self.__barcodes_df.rename(columns={'actual_ice_id': 'known_seq_id'},
                                  inplace=True)
        self.__barcodes_df['known_seq_id'] = \
            self.__barcodes_df['known_seq_id'].astype(str)

        #>> Transferring well into 'str'
        self.__barcodes_df['well'] = \
            self.__barcodes_df['well'].astype(str)
        #>> Checking all columns in barcodes_df in the future

        self.__barcodes_df.set_index(
            ['forward', 'reverse', 'barcode_type'], inplace=True)

        # Index sequence / template files:
        #>> replace bwa by minimap2
        if seq_files:
            for templ_filename in self.__seq_files.values():
                if not os.path.exists(templ_filename + '.mmi'):
                    subprocess.call(['minimap2', '-x', 'map-ont', '-d', templ_filename + '.mmi', templ_filename])

    def demultiplex(self, tolerance=16, num_threads=8, indiv_strand=True):
        return demultiplex.demultiplex(self.__barcodes,
                                        self.__in_dir,
                                        self.__min_length,
                                        self.__max_read_files,
                                        self.__out_dir,
                                        tolerance=tolerance,
                                        num_threads=num_threads,
                                        indiv_strand=indiv_strand)


    def medaka_alignments(self, barcode_reads, num_threads, medaka_model='r941_min_hac_g507'):
        '''Score alignments.'''

        write_queue = mp.Manager().Queue()
        results_thread = medaka_utils.medakaResult(sorted(self.__seq_files.keys()),
                                               self.__barcodes_df,
                                               write_queue)
        results_thread.start()
        with mp.Pool(int(num_threads/2)) as mpool:
            for barcodes, reads_filename in barcode_reads.items():
                mpool.apply_async(
                    _medaka_alignment,
                    (self.__out_dir,
                     barcodes,
                     reads_filename,
                     self.__get_seq_files(barcodes),
                     write_queue,
                     medaka_model))
            mpool.close()
            mpool.join()

        # Update summary:
        results_thread.close()
        return results_thread.write()# (os.path.join(self.__out_dir, 'medaka_'))

    def medaka_variants_calling(self, barcode_reads, medaka_model='r941_min_hac_variant_g507'):
        for barcodes, reads_filename in barcode_reads.items():
            medaka_variants_calling(self.__out_dir,
                                    barcodes,
                                    reads_filename,
                                    self.__get_seq_files(barcodes),
                                    medaka_model)

    def __get_seq_files(self, barcodes):
        '''Get appropriate sequence files.'''
        try:
            seq_id = self.__barcodes_df.loc[barcodes, 'known_seq_id']

            if seq_id:
                return {seq_id: self.__seq_files[seq_id]}
        except KeyError:
            print('Unexpected barcodes: ' + str(barcodes))
            return {}

        return self.__seq_files
    
    def score_alignments(self, barcode_reads, num_threads=8, risk_threshold=0.75, risk_threshold2=0.15, mode='minimap'):
        '''Score alignments.'''
        num_threads = num_threads if num_threads > 0 else mp.cpu_count()
        print('Running pathway with %d threads' % num_threads)

        write_queue = mp.Manager().Queue()
        results_thread = results.ResultsThread(sorted(self.__seq_files.keys()),
                                               self.__barcodes_df,
                                               write_queue)
        results_thread.start()

        callback_msg = []
        errorback_msg = []
        with mp.Pool(num_threads) as mpool:
            for barcodes, reads_filename in barcode_reads.items():
                # r = _score_alignment(self.__out_dir,
                #                    barcodes,
                #                    reads_filename,
                #                    self.__get_seq_files(barcodes),
                #                    1,
                #                    write_queue,
                #                    risk_threshold,
                #                    risk_threshold2,
                #                    'parallel',
                #                    mode)

                mpool.apply_async(_score_alignment,
                                  (self.__out_dir,
                                   barcodes,
                                   reads_filename,
                                   self.__get_seq_files(barcodes),
                                   1,
                                   write_queue,
                                   risk_threshold,
                                   risk_threshold2,
                                   'parallel',
                                   mode),
                                  callback=callback_msg.append,
                                  error_callback=errorback_msg.append
                                 ) 
            mpool.close()
            mpool.join()

        if len(errorback_msg) > 0:
            print([e for e in errorback_msg if e])
        
        # Update summary:
        results_thread.close()
        # results_thread.write(os.path.join(self.__out_dir, f'{mode}_'))
        return results_thread.write()
    
    def __call__(self, tolerance=16, num_threads=8):
        num_threads = num_threads if num_threads > 0 else mp.cpu_count()
        print('Running pathway with %d threads' % num_threads)
        barcodes = self.demultiplex(tolerance, num_threads)
        self.medaka_alignments(barcodes, num_threads)


def medaka_variants_calling(dir_name, barcodes, reads_filename, seq_files, medaka_model):
    for seq_id, seq_filename in seq_files.items():
        barcodes_dir_name = utils.get_dir(dir_name, barcodes, seq_id)
        medaka_dir_name = os.path.join(barcodes_dir_name, '%s_medaka_var_call' %barcodes[2])
        vcf_filename = os.path.join(medaka_dir_name, 'medaka.annotated.vcf')
        if not os.path.isdir(medaka_dir_name):
            stdout = subprocess.check_output(f"medaka_haploid_variant -i {reads_filename} -r {seq_filename} -o {medaka_dir_name} -m {medaka_model}", shell=True)

        vcf_df, _ = vcf_utils.vcf_to_df(vcf_filename,)
        vcf_df.to_csv(os.path.join('./', 'medaka.annotated.csv'), index=False, mode='a')


def _medaka_alignment(dir_name, barcodes, reads_filename, seq_files,
                     write_queue, medaka_model):

    '''Score an alignment.'''
    for seq_id, seq_filename in seq_files.items():
        barcode_dir_name = utils.get_dir(dir_name, barcodes, seq_id)
        medaka_dir_name = os.path.join(barcode_dir_name, '%s_medaka' %barcodes[2])
        consensus_filename = os.path.join(medaka_dir_name, 'consensus.fasta')
        vcf_filename = os.path.join(medaka_dir_name, 'medaka.annotated.vcf')
        if not os.path.isdir(medaka_dir_name) or not os.path.exists(consensus_filename):
            os.mkdir(medaka_dir_name)
            
            prc = subprocess.Popen(['medaka_consensus',
                                    '-i', reads_filename,
                                    '-d', seq_filename,
                                    '-o', medaka_dir_name,
                                    '-t', '1',
                                    '-m', medaka_model],
                                    stdout=subprocess.PIPE)
            
            prc.wait()
            
            with open(medaka_dir_name + '.log', 'wb') as f:
                f.writelines(prc.stdout.readlines())
        
        medaka_utils.consensus_compare(consensus_filename,
                                       seq_filename,
                                       seq_id,
                                       barcodes,
                                       write_queue)


def _get_seq_files(filename):
    '''Get seq files.'''
    seq_files = {}

    if os.path.isdir(filename):
        for fle in os.listdir(filename):
            name, ext = os.path.splitext(os.path.basename(fle))

            if ext == '.fasta':
                seq_files[name] = os.path.join(filename, fle)
    else:
        seq_files[os.path.splitext(os.path.basename(filename))[0]] = filename

    return seq_files


def main_medaka(args):
    '''main method.'''
    seq_files = {}
    import uuid


    for seq_file in args[6:]:
        seq_files.update(_get_seq_files(seq_file))

    if len(args) == 8:
        medaka_model = args[7:]
    else:
        medaka_model = 'r1041_e82_400bps_hac_v5.0.0'

    aligner = PathwayAligner(out_dir=os.path.join(args[0], time.strftime("%Y%m%d%H%M%S", time.localtime()) + '_' + str(uuid.uuid4())),
                             in_dir=args[1],
                             seq_files=seq_files,
                             min_length=int(args[2]),
                             max_read_files=int(args[3]))

    aligner.medaka_alignments(aligner.demultiplex(tolerance=int(args[4]), num_threads=int(args[5])), num_threads=int(args[5]),
    medaka_model=medaka_model)


def run_align(in_dir, out_dir, min_length=200, max_read_files=5000, 
               tolerance=16, num_threads=1, seq_dir='.', medaka_model='r941_min_hac_g507', excel=None):
    seq_files = {}
    barcodes_df = None
    if excel is not None:
        if not os.path.exists(seq_dir):
            os.mkdir(seq_dir)
        barcodes_df = parse_barcode_excel(excel, seq_dir)  

    seq_files.update(_get_seq_files(seq_dir))

    
    aligner = PathwayAligner(out_dir=out_dir,
                             in_dir=in_dir,
                             seq_files=seq_files,   
                             min_length=int(min_length),
                             max_read_files=int(max_read_files), 
                             barcodes_df=barcodes_df)

    barcodes = {}
    for dir_name in os.listdir(out_dir):
        if dir_name.count('.') == 0 and os.path.isdir(os.path.join(out_dir, dir_name)):
            for file in os.listdir(os.path.join(out_dir, dir_name)):
                if file.endswith('.fastq') : #and (dir_name.startswith('GTACATTCAGTGACACTATCGGTT_ACGATTAGTTCTCTACGTGTGTGG')):
                    barcodes[tuple(dir_name.split('_') + [file.split('_')[0]])] = os.path.join(out_dir, dir_name, file)

    if len(barcodes) < 1:
        barcodes = aligner.demultiplex(tolerance=tolerance, num_threads=int(num_threads))

    score_alignment = aligner.score_alignments(barcode_reads=barcodes, num_threads=int(num_threads), mode='minimap')['raw_summary'].reset_index()

    # return

    medaka_alignment = aligner.medaka_alignments(barcode_reads=barcodes,  num_threads=int(num_threads),medaka_model=medaka_model)['raw_summary'].reset_index()
    return barcodes_df, medaka_alignment, score_alignment

if __name__ == '__main__':
    parse_barcode_excel('barcode_reference_sample_2023-11-10.xlsx', './seq_data')
